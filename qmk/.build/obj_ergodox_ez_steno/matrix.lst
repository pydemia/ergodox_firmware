   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.init_cols,"ax",@progbits
  12               	init_cols:
  13               	.LFB138:
  14               		.file 1 "keyboards/ergodox/ez/matrix.c"
   1:keyboards/ergodox/ez/matrix.c **** /*
   2:keyboards/ergodox/ez/matrix.c **** 
   3:keyboards/ergodox/ez/matrix.c **** Note for ErgoDox EZ customizers: Here be dragons!
   4:keyboards/ergodox/ez/matrix.c **** This is not a file you want to be messing with.
   5:keyboards/ergodox/ez/matrix.c **** All of the interesting stuff for you is under keymaps/ :)
   6:keyboards/ergodox/ez/matrix.c **** Love, Erez
   7:keyboards/ergodox/ez/matrix.c **** 
   8:keyboards/ergodox/ez/matrix.c **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   9:keyboards/ergodox/ez/matrix.c **** 
  10:keyboards/ergodox/ez/matrix.c **** This program is free software: you can redistribute it and/or modify
  11:keyboards/ergodox/ez/matrix.c **** it under the terms of the GNU General Public License as published by
  12:keyboards/ergodox/ez/matrix.c **** the Free Software Foundation, either version 2 of the License, or
  13:keyboards/ergodox/ez/matrix.c **** (at your option) any later version.
  14:keyboards/ergodox/ez/matrix.c **** 
  15:keyboards/ergodox/ez/matrix.c **** This program is distributed in the hope that it will be useful,
  16:keyboards/ergodox/ez/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  17:keyboards/ergodox/ez/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  18:keyboards/ergodox/ez/matrix.c **** GNU General Public License for more details.
  19:keyboards/ergodox/ez/matrix.c **** 
  20:keyboards/ergodox/ez/matrix.c **** You should have received a copy of the GNU General Public License
  21:keyboards/ergodox/ez/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  22:keyboards/ergodox/ez/matrix.c **** */
  23:keyboards/ergodox/ez/matrix.c **** 
  24:keyboards/ergodox/ez/matrix.c **** /*
  25:keyboards/ergodox/ez/matrix.c ****  * scan matrix
  26:keyboards/ergodox/ez/matrix.c ****  */
  27:keyboards/ergodox/ez/matrix.c **** #include <stdint.h>
  28:keyboards/ergodox/ez/matrix.c **** #include <stdbool.h>
  29:keyboards/ergodox/ez/matrix.c **** #include <avr/io.h>
  30:keyboards/ergodox/ez/matrix.c **** #include "wait.h"
  31:keyboards/ergodox/ez/matrix.c **** #include "action_layer.h"
  32:keyboards/ergodox/ez/matrix.c **** #include "print.h"
  33:keyboards/ergodox/ez/matrix.c **** #include "debug.h"
  34:keyboards/ergodox/ez/matrix.c **** #include "util.h"
  35:keyboards/ergodox/ez/matrix.c **** #include "matrix.h"
  36:keyboards/ergodox/ez/matrix.c **** #include "ez.h"
  37:keyboards/ergodox/ez/matrix.c **** #include "i2cmaster.h"
  38:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
  39:keyboards/ergodox/ez/matrix.c **** #include  "timer.h"
  40:keyboards/ergodox/ez/matrix.c **** #endif
  41:keyboards/ergodox/ez/matrix.c **** 
  42:keyboards/ergodox/ez/matrix.c **** /*
  43:keyboards/ergodox/ez/matrix.c ****  * This constant define not debouncing time in msecs, but amount of matrix
  44:keyboards/ergodox/ez/matrix.c ****  * scan loops which should be made to get stable debounced results.
  45:keyboards/ergodox/ez/matrix.c ****  *
  46:keyboards/ergodox/ez/matrix.c ****  * On Ergodox matrix scan rate is relatively low, because of slow I2C.
  47:keyboards/ergodox/ez/matrix.c ****  * Now it's only 317 scans/second, or about 3.15 msec/scan.
  48:keyboards/ergodox/ez/matrix.c ****  * According to Cherry specs, debouncing time is 5 msec.
  49:keyboards/ergodox/ez/matrix.c ****  *
  50:keyboards/ergodox/ez/matrix.c ****  * And so, there is no sense to have DEBOUNCE higher than 2.
  51:keyboards/ergodox/ez/matrix.c ****  */
  52:keyboards/ergodox/ez/matrix.c **** 
  53:keyboards/ergodox/ez/matrix.c **** #ifndef DEBOUNCE
  54:keyboards/ergodox/ez/matrix.c **** #   define DEBOUNCE	5
  55:keyboards/ergodox/ez/matrix.c **** #endif
  56:keyboards/ergodox/ez/matrix.c **** static uint8_t debouncing = DEBOUNCE;
  57:keyboards/ergodox/ez/matrix.c **** 
  58:keyboards/ergodox/ez/matrix.c **** /* matrix state(1:on, 0:off) */
  59:keyboards/ergodox/ez/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  60:keyboards/ergodox/ez/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  61:keyboards/ergodox/ez/matrix.c **** 
  62:keyboards/ergodox/ez/matrix.c **** static matrix_row_t read_cols(uint8_t row);
  63:keyboards/ergodox/ez/matrix.c **** static void init_cols(void);
  64:keyboards/ergodox/ez/matrix.c **** static void unselect_rows(void);
  65:keyboards/ergodox/ez/matrix.c **** static void select_row(uint8_t row);
  66:keyboards/ergodox/ez/matrix.c **** 
  67:keyboards/ergodox/ez/matrix.c **** static uint8_t mcp23018_reset_loop;
  68:keyboards/ergodox/ez/matrix.c **** 
  69:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
  70:keyboards/ergodox/ez/matrix.c **** uint32_t matrix_timer;
  71:keyboards/ergodox/ez/matrix.c **** uint32_t matrix_scan_count;
  72:keyboards/ergodox/ez/matrix.c **** #endif
  73:keyboards/ergodox/ez/matrix.c **** 
  74:keyboards/ergodox/ez/matrix.c **** 
  75:keyboards/ergodox/ez/matrix.c **** __attribute__ ((weak))
  76:keyboards/ergodox/ez/matrix.c **** void matrix_init_user(void) {}
  77:keyboards/ergodox/ez/matrix.c **** 
  78:keyboards/ergodox/ez/matrix.c **** __attribute__ ((weak))
  79:keyboards/ergodox/ez/matrix.c **** void matrix_scan_user(void) {}
  80:keyboards/ergodox/ez/matrix.c **** 
  81:keyboards/ergodox/ez/matrix.c **** __attribute__ ((weak))
  82:keyboards/ergodox/ez/matrix.c **** void matrix_init_kb(void) {
  83:keyboards/ergodox/ez/matrix.c ****   matrix_init_user();
  84:keyboards/ergodox/ez/matrix.c **** }
  85:keyboards/ergodox/ez/matrix.c **** 
  86:keyboards/ergodox/ez/matrix.c **** __attribute__ ((weak))
  87:keyboards/ergodox/ez/matrix.c **** void matrix_scan_kb(void) {
  88:keyboards/ergodox/ez/matrix.c ****   matrix_scan_user();
  89:keyboards/ergodox/ez/matrix.c **** }
  90:keyboards/ergodox/ez/matrix.c **** 
  91:keyboards/ergodox/ez/matrix.c **** inline
  92:keyboards/ergodox/ez/matrix.c **** uint8_t matrix_rows(void)
  93:keyboards/ergodox/ez/matrix.c **** {
  94:keyboards/ergodox/ez/matrix.c ****     return MATRIX_ROWS;
  95:keyboards/ergodox/ez/matrix.c **** }
  96:keyboards/ergodox/ez/matrix.c **** 
  97:keyboards/ergodox/ez/matrix.c **** inline
  98:keyboards/ergodox/ez/matrix.c **** uint8_t matrix_cols(void)
  99:keyboards/ergodox/ez/matrix.c **** {
 100:keyboards/ergodox/ez/matrix.c ****     return MATRIX_COLS;
 101:keyboards/ergodox/ez/matrix.c **** }
 102:keyboards/ergodox/ez/matrix.c **** 
 103:keyboards/ergodox/ez/matrix.c **** void matrix_init(void)
 104:keyboards/ergodox/ez/matrix.c **** {
 105:keyboards/ergodox/ez/matrix.c ****     // initialize row and col
 106:keyboards/ergodox/ez/matrix.c **** 
 107:keyboards/ergodox/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 108:keyboards/ergodox/ez/matrix.c **** 
 109:keyboards/ergodox/ez/matrix.c **** 
 110:keyboards/ergodox/ez/matrix.c ****     unselect_rows();
 111:keyboards/ergodox/ez/matrix.c ****     init_cols();
 112:keyboards/ergodox/ez/matrix.c **** 
 113:keyboards/ergodox/ez/matrix.c ****     // initialize matrix state: all keys off
 114:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 115:keyboards/ergodox/ez/matrix.c ****         matrix[i] = 0;
 116:keyboards/ergodox/ez/matrix.c ****         matrix_debouncing[i] = 0;
 117:keyboards/ergodox/ez/matrix.c ****     }
 118:keyboards/ergodox/ez/matrix.c **** 
 119:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 120:keyboards/ergodox/ez/matrix.c ****     matrix_timer = timer_read32();
 121:keyboards/ergodox/ez/matrix.c ****     matrix_scan_count = 0;
 122:keyboards/ergodox/ez/matrix.c **** #endif
 123:keyboards/ergodox/ez/matrix.c **** 
 124:keyboards/ergodox/ez/matrix.c ****     matrix_init_kb();
 125:keyboards/ergodox/ez/matrix.c **** 
 126:keyboards/ergodox/ez/matrix.c **** }
 127:keyboards/ergodox/ez/matrix.c **** 
 128:keyboards/ergodox/ez/matrix.c **** void matrix_power_up(void) {
 129:keyboards/ergodox/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 130:keyboards/ergodox/ez/matrix.c **** 
 131:keyboards/ergodox/ez/matrix.c ****     unselect_rows();
 132:keyboards/ergodox/ez/matrix.c ****     init_cols();
 133:keyboards/ergodox/ez/matrix.c **** 
 134:keyboards/ergodox/ez/matrix.c ****     // initialize matrix state: all keys off
 135:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 136:keyboards/ergodox/ez/matrix.c ****         matrix[i] = 0;
 137:keyboards/ergodox/ez/matrix.c ****         matrix_debouncing[i] = 0;
 138:keyboards/ergodox/ez/matrix.c ****     }
 139:keyboards/ergodox/ez/matrix.c **** 
 140:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 141:keyboards/ergodox/ez/matrix.c ****     matrix_timer = timer_read32();
 142:keyboards/ergodox/ez/matrix.c ****     matrix_scan_count = 0;
 143:keyboards/ergodox/ez/matrix.c **** #endif
 144:keyboards/ergodox/ez/matrix.c **** 
 145:keyboards/ergodox/ez/matrix.c **** }
 146:keyboards/ergodox/ez/matrix.c **** 
 147:keyboards/ergodox/ez/matrix.c **** uint8_t matrix_scan(void)
 148:keyboards/ergodox/ez/matrix.c **** {
 149:keyboards/ergodox/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 150:keyboards/ergodox/ez/matrix.c ****         if (++mcp23018_reset_loop == 0) {
 151:keyboards/ergodox/ez/matrix.c ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 152:keyboards/ergodox/ez/matrix.c ****             // this will be approx bit more frequent than once per second
 153:keyboards/ergodox/ez/matrix.c ****             print("trying to reset mcp23018\n");
 154:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = init_mcp23018();
 155:keyboards/ergodox/ez/matrix.c ****             if (mcp23018_status) {
 156:keyboards/ergodox/ez/matrix.c ****                 print("left side not responding\n");
 157:keyboards/ergodox/ez/matrix.c ****             } else {
 158:keyboards/ergodox/ez/matrix.c ****                 print("left side attached\n");
 159:keyboards/ergodox/ez/matrix.c ****                 ergodox_blink_all_leds();
 160:keyboards/ergodox/ez/matrix.c ****             }
 161:keyboards/ergodox/ez/matrix.c ****         }
 162:keyboards/ergodox/ez/matrix.c ****     }
 163:keyboards/ergodox/ez/matrix.c **** 
 164:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 165:keyboards/ergodox/ez/matrix.c ****     matrix_scan_count++;
 166:keyboards/ergodox/ez/matrix.c **** 
 167:keyboards/ergodox/ez/matrix.c ****     uint32_t timer_now = timer_read32();
 168:keyboards/ergodox/ez/matrix.c ****     if (TIMER_DIFF_32(timer_now, matrix_timer)>1000) {
 169:keyboards/ergodox/ez/matrix.c ****         print("matrix scan frequency: ");
 170:keyboards/ergodox/ez/matrix.c ****         pdec(matrix_scan_count);
 171:keyboards/ergodox/ez/matrix.c ****         print("\n");
 172:keyboards/ergodox/ez/matrix.c **** 
 173:keyboards/ergodox/ez/matrix.c ****         matrix_timer = timer_now;
 174:keyboards/ergodox/ez/matrix.c ****         matrix_scan_count = 0;
 175:keyboards/ergodox/ez/matrix.c ****     }
 176:keyboards/ergodox/ez/matrix.c **** #endif
 177:keyboards/ergodox/ez/matrix.c **** 
 178:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 179:keyboards/ergodox/ez/matrix.c ****         select_row(i);
 180:keyboards/ergodox/ez/matrix.c ****         wait_us(30);  // without this wait read unstable value.
 181:keyboards/ergodox/ez/matrix.c ****         matrix_row_t cols = read_cols(i);
 182:keyboards/ergodox/ez/matrix.c ****         if (matrix_debouncing[i] != cols) {
 183:keyboards/ergodox/ez/matrix.c ****             matrix_debouncing[i] = cols;
 184:keyboards/ergodox/ez/matrix.c ****             if (debouncing) {
 185:keyboards/ergodox/ez/matrix.c ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 186:keyboards/ergodox/ez/matrix.c ****             }
 187:keyboards/ergodox/ez/matrix.c ****             debouncing = DEBOUNCE;
 188:keyboards/ergodox/ez/matrix.c ****         }
 189:keyboards/ergodox/ez/matrix.c ****         unselect_rows();
 190:keyboards/ergodox/ez/matrix.c ****     }
 191:keyboards/ergodox/ez/matrix.c **** 
 192:keyboards/ergodox/ez/matrix.c ****     if (debouncing) {
 193:keyboards/ergodox/ez/matrix.c ****         if (--debouncing) {
 194:keyboards/ergodox/ez/matrix.c ****             wait_us(1);
 195:keyboards/ergodox/ez/matrix.c ****             // this should be wait_ms(1) but has been left as-is at EZ's request
 196:keyboards/ergodox/ez/matrix.c ****         } else {
 197:keyboards/ergodox/ez/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 198:keyboards/ergodox/ez/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 199:keyboards/ergodox/ez/matrix.c ****             }
 200:keyboards/ergodox/ez/matrix.c ****         }
 201:keyboards/ergodox/ez/matrix.c ****     }
 202:keyboards/ergodox/ez/matrix.c **** 
 203:keyboards/ergodox/ez/matrix.c ****     matrix_scan_quantum();
 204:keyboards/ergodox/ez/matrix.c **** 
 205:keyboards/ergodox/ez/matrix.c ****     return 1;
 206:keyboards/ergodox/ez/matrix.c **** }
 207:keyboards/ergodox/ez/matrix.c **** 
 208:keyboards/ergodox/ez/matrix.c **** bool matrix_is_modified(void)
 209:keyboards/ergodox/ez/matrix.c **** {
 210:keyboards/ergodox/ez/matrix.c ****     if (debouncing) return false;
 211:keyboards/ergodox/ez/matrix.c ****     return true;
 212:keyboards/ergodox/ez/matrix.c **** }
 213:keyboards/ergodox/ez/matrix.c **** 
 214:keyboards/ergodox/ez/matrix.c **** inline
 215:keyboards/ergodox/ez/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 216:keyboards/ergodox/ez/matrix.c **** {
 217:keyboards/ergodox/ez/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 218:keyboards/ergodox/ez/matrix.c **** }
 219:keyboards/ergodox/ez/matrix.c **** 
 220:keyboards/ergodox/ez/matrix.c **** inline
 221:keyboards/ergodox/ez/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 222:keyboards/ergodox/ez/matrix.c **** {
 223:keyboards/ergodox/ez/matrix.c ****     return matrix[row];
 224:keyboards/ergodox/ez/matrix.c **** }
 225:keyboards/ergodox/ez/matrix.c **** 
 226:keyboards/ergodox/ez/matrix.c **** void matrix_print(void)
 227:keyboards/ergodox/ez/matrix.c **** {
 228:keyboards/ergodox/ez/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 229:keyboards/ergodox/ez/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 230:keyboards/ergodox/ez/matrix.c ****         phex(row); print(": ");
 231:keyboards/ergodox/ez/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 232:keyboards/ergodox/ez/matrix.c ****         print("\n");
 233:keyboards/ergodox/ez/matrix.c ****     }
 234:keyboards/ergodox/ez/matrix.c **** }
 235:keyboards/ergodox/ez/matrix.c **** 
 236:keyboards/ergodox/ez/matrix.c **** uint8_t matrix_key_count(void)
 237:keyboards/ergodox/ez/matrix.c **** {
 238:keyboards/ergodox/ez/matrix.c ****     uint8_t count = 0;
 239:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 240:keyboards/ergodox/ez/matrix.c ****         count += bitpop16(matrix[i]);
 241:keyboards/ergodox/ez/matrix.c ****     }
 242:keyboards/ergodox/ez/matrix.c ****     return count;
 243:keyboards/ergodox/ez/matrix.c **** }
 244:keyboards/ergodox/ez/matrix.c **** 
 245:keyboards/ergodox/ez/matrix.c **** /* Column pin configuration
 246:keyboards/ergodox/ez/matrix.c ****  *
 247:keyboards/ergodox/ez/matrix.c ****  * Teensy
 248:keyboards/ergodox/ez/matrix.c ****  * col: 0   1   2   3   4   5
 249:keyboards/ergodox/ez/matrix.c ****  * pin: F0  F1  F4  F5  F6  F7
 250:keyboards/ergodox/ez/matrix.c ****  *
 251:keyboards/ergodox/ez/matrix.c ****  * MCP23018
 252:keyboards/ergodox/ez/matrix.c ****  * col: 0   1   2   3   4   5
 253:keyboards/ergodox/ez/matrix.c ****  * pin: B5  B4  B3  B2  B1  B0
 254:keyboards/ergodox/ez/matrix.c ****  */
 255:keyboards/ergodox/ez/matrix.c **** static void  init_cols(void)
 256:keyboards/ergodox/ez/matrix.c **** {
  15               		.loc 1 256 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 257:keyboards/ergodox/ez/matrix.c ****     // init on mcp23018
 258:keyboards/ergodox/ez/matrix.c ****     // not needed, already done as part of init_mcp23018()
 259:keyboards/ergodox/ez/matrix.c **** 
 260:keyboards/ergodox/ez/matrix.c ****     // init on teensy
 261:keyboards/ergodox/ez/matrix.c ****     // Input with pull-up(DDR:0, PORT:1)
 262:keyboards/ergodox/ez/matrix.c ****     DDRF  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
  21               		.loc 1 262 0
  22 0000 80B3      		in r24,0x10
  23 0002 8C70      		andi r24,lo8(12)
  24 0004 80BB      		out 0x10,r24
 263:keyboards/ergodox/ez/matrix.c ****     PORTF |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
  25               		.loc 1 263 0
  26 0006 81B3      		in r24,0x11
  27 0008 836F      		ori r24,lo8(-13)
  28 000a 81BB      		out 0x11,r24
  29 000c 0895      		ret
  30               		.cfi_endproc
  31               	.LFE138:
  33               		.section	.text.unselect_rows,"ax",@progbits
  35               	unselect_rows:
  36               	.LFB140:
 264:keyboards/ergodox/ez/matrix.c **** }
 265:keyboards/ergodox/ez/matrix.c **** 
 266:keyboards/ergodox/ez/matrix.c **** static matrix_row_t read_cols(uint8_t row)
 267:keyboards/ergodox/ez/matrix.c **** {
 268:keyboards/ergodox/ez/matrix.c ****     if (row < 7) {
 269:keyboards/ergodox/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 270:keyboards/ergodox/ez/matrix.c ****             return 0;
 271:keyboards/ergodox/ez/matrix.c ****         } else {
 272:keyboards/ergodox/ez/matrix.c ****             uint8_t data = 0;
 273:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 274:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 275:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 276:keyboards/ergodox/ez/matrix.c ****             data = i2c_readNak();
 277:keyboards/ergodox/ez/matrix.c ****             data = ~data;
 278:keyboards/ergodox/ez/matrix.c ****         out:
 279:keyboards/ergodox/ez/matrix.c ****             i2c_stop();
 280:keyboards/ergodox/ez/matrix.c ****             return data;
 281:keyboards/ergodox/ez/matrix.c ****         }
 282:keyboards/ergodox/ez/matrix.c ****     } else {
 283:keyboards/ergodox/ez/matrix.c ****         // read from teensy
 284:keyboards/ergodox/ez/matrix.c ****         return
 285:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 286:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 287:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 288:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 289:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 290:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 291:keyboards/ergodox/ez/matrix.c ****     }
 292:keyboards/ergodox/ez/matrix.c **** }
 293:keyboards/ergodox/ez/matrix.c **** 
 294:keyboards/ergodox/ez/matrix.c **** /* Row pin configuration
 295:keyboards/ergodox/ez/matrix.c ****  *
 296:keyboards/ergodox/ez/matrix.c ****  * Teensy
 297:keyboards/ergodox/ez/matrix.c ****  * row: 7   8   9   10  11  12  13
 298:keyboards/ergodox/ez/matrix.c ****  * pin: B0  B1  B2  B3  D2  D3  C6
 299:keyboards/ergodox/ez/matrix.c ****  *
 300:keyboards/ergodox/ez/matrix.c ****  * MCP23018
 301:keyboards/ergodox/ez/matrix.c ****  * row: 0   1   2   3   4   5   6
 302:keyboards/ergodox/ez/matrix.c ****  * pin: A0  A1  A2  A3  A4  A5  A6
 303:keyboards/ergodox/ez/matrix.c ****  */
 304:keyboards/ergodox/ez/matrix.c **** static void unselect_rows(void)
 305:keyboards/ergodox/ez/matrix.c **** {
  37               		.loc 1 305 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
 306:keyboards/ergodox/ez/matrix.c ****     // unselect on mcp23018
 307:keyboards/ergodox/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
  43               		.loc 1 307 0
  44 0000 8091 0000 		lds r24,mcp23018_status
  45 0004 8111      		cpse r24,__zero_reg__
  46 0006 00C0      		rjmp .L3
 308:keyboards/ergodox/ez/matrix.c ****         // do nothing
 309:keyboards/ergodox/ez/matrix.c ****     } else {
 310:keyboards/ergodox/ez/matrix.c ****         // set all rows hi-Z : 1
 311:keyboards/ergodox/ez/matrix.c ****         mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
  47               		.loc 1 311 0
  48 0008 80E4      		ldi r24,lo8(64)
  49 000a 0E94 0000 		call i2c_start
  50               	.LVL0:
  51 000e 8093 0000 		sts mcp23018_status,r24
  52 0012 8111      		cpse r24,__zero_reg__
  53 0014 00C0      		rjmp .L5
 312:keyboards/ergodox/ez/matrix.c ****         mcp23018_status = i2c_write(GPIOA);             if (mcp23018_status) goto out;
  54               		.loc 1 312 0
  55 0016 82E1      		ldi r24,lo8(18)
  56 0018 0E94 0000 		call i2c_write
  57               	.LVL1:
  58 001c 8093 0000 		sts mcp23018_status,r24
  59 0020 8111      		cpse r24,__zero_reg__
  60 0022 00C0      		rjmp .L5
 313:keyboards/ergodox/ez/matrix.c ****         mcp23018_status = i2c_write( 0xFF
  61               		.loc 1 313 0
  62 0024 8FEF      		ldi r24,lo8(-1)
  63 0026 0E94 0000 		call i2c_write
  64               	.LVL2:
  65 002a 8093 0000 		sts mcp23018_status,r24
  66               	.L5:
 314:keyboards/ergodox/ez/matrix.c ****                               & ~(0<<7)
 315:keyboards/ergodox/ez/matrix.c ****                           );                            if (mcp23018_status) goto out;
 316:keyboards/ergodox/ez/matrix.c ****     out:
 317:keyboards/ergodox/ez/matrix.c ****         i2c_stop();
  67               		.loc 1 317 0
  68 002e 0E94 0000 		call i2c_stop
  69               	.LVL3:
  70               	.L3:
 318:keyboards/ergodox/ez/matrix.c ****     }
 319:keyboards/ergodox/ez/matrix.c **** 
 320:keyboards/ergodox/ez/matrix.c ****     // unselect on teensy
 321:keyboards/ergodox/ez/matrix.c ****     // Hi-Z(DDR:0, PORT:0) to unselect
 322:keyboards/ergodox/ez/matrix.c ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
  71               		.loc 1 322 0
  72 0032 84B1      		in r24,0x4
  73 0034 807F      		andi r24,lo8(-16)
  74 0036 84B9      		out 0x4,r24
 323:keyboards/ergodox/ez/matrix.c ****     PORTB &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
  75               		.loc 1 323 0
  76 0038 85B1      		in r24,0x5
  77 003a 807F      		andi r24,lo8(-16)
  78 003c 85B9      		out 0x5,r24
 324:keyboards/ergodox/ez/matrix.c ****     DDRD  &= ~(1<<2 | 1<<3);
  79               		.loc 1 324 0
  80 003e 8AB1      		in r24,0xa
  81 0040 837F      		andi r24,lo8(-13)
  82 0042 8AB9      		out 0xa,r24
 325:keyboards/ergodox/ez/matrix.c ****     PORTD &= ~(1<<2 | 1<<3);
  83               		.loc 1 325 0
  84 0044 8BB1      		in r24,0xb
  85 0046 837F      		andi r24,lo8(-13)
  86 0048 8BB9      		out 0xb,r24
 326:keyboards/ergodox/ez/matrix.c ****     DDRC  &= ~(1<<6);
  87               		.loc 1 326 0
  88 004a 3E98      		cbi 0x7,6
 327:keyboards/ergodox/ez/matrix.c ****     PORTC &= ~(1<<6);
  89               		.loc 1 327 0
  90 004c 4698      		cbi 0x8,6
  91 004e 0895      		ret
  92               		.cfi_endproc
  93               	.LFE140:
  95               		.section	.text.matrix_scan_user,"ax",@progbits
  96               		.weak	matrix_scan_user
  98               	matrix_scan_user:
  99               	.LFB125:
  79:keyboards/ergodox/ez/matrix.c **** 
 100               		.loc 1 79 0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
 106 0000 0895      		ret
 107               		.cfi_endproc
 108               	.LFE125:
 110               		.set	matrix_scan_user.localalias.0,matrix_scan_user
 111               		.section	.text.matrix_init_user,"ax",@progbits
 112               		.weak	matrix_init_user
 114               	matrix_init_user:
 115               	.LFB143:
 116               		.cfi_startproc
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 121 0000 0C94 0000 		jmp matrix_scan_user.localalias.0
 122               		.cfi_endproc
 123               	.LFE143:
 125               		.section	.text.matrix_init_kb,"ax",@progbits
 126               		.weak	matrix_init_kb
 128               	matrix_init_kb:
 129               	.LFB126:
  82:keyboards/ergodox/ez/matrix.c ****   matrix_init_user();
 130               		.loc 1 82 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
  83:keyboards/ergodox/ez/matrix.c **** }
 136               		.loc 1 83 0
 137 0000 0C94 0000 		jmp matrix_init_user
 138               	.LVL4:
 139               		.cfi_endproc
 140               	.LFE126:
 142               		.section	.text.matrix_scan_kb,"ax",@progbits
 143               		.weak	matrix_scan_kb
 145               	matrix_scan_kb:
 146               	.LFB127:
  87:keyboards/ergodox/ez/matrix.c ****   matrix_scan_user();
 147               		.loc 1 87 0
 148               		.cfi_startproc
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 151               	/* stack size = 0 */
 152               	.L__stack_usage = 0
  88:keyboards/ergodox/ez/matrix.c **** }
 153               		.loc 1 88 0
 154 0000 0C94 0000 		jmp matrix_scan_user
 155               	.LVL5:
 156               		.cfi_endproc
 157               	.LFE127:
 159               		.section	.text.matrix_rows,"ax",@progbits
 160               	.global	matrix_rows
 162               	matrix_rows:
 163               	.LFB128:
  93:keyboards/ergodox/ez/matrix.c ****     return MATRIX_ROWS;
 164               		.loc 1 93 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
  95:keyboards/ergodox/ez/matrix.c **** 
 170               		.loc 1 95 0
 171 0000 8EE0      		ldi r24,lo8(14)
 172 0002 0895      		ret
 173               		.cfi_endproc
 174               	.LFE128:
 176               		.section	.text.matrix_cols,"ax",@progbits
 177               	.global	matrix_cols
 179               	matrix_cols:
 180               	.LFB129:
  99:keyboards/ergodox/ez/matrix.c ****     return MATRIX_COLS;
 181               		.loc 1 99 0
 182               		.cfi_startproc
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
 101:keyboards/ergodox/ez/matrix.c **** 
 187               		.loc 1 101 0
 188 0000 86E0      		ldi r24,lo8(6)
 189 0002 0895      		ret
 190               		.cfi_endproc
 191               	.LFE129:
 193               		.section	.text.matrix_init,"ax",@progbits
 194               	.global	matrix_init
 196               	matrix_init:
 197               	.LFB130:
 104:keyboards/ergodox/ez/matrix.c ****     // initialize row and col
 198               		.loc 1 104 0
 199               		.cfi_startproc
 200               	/* prologue: function */
 201               	/* frame size = 0 */
 202               	/* stack size = 0 */
 203               	.L__stack_usage = 0
 107:keyboards/ergodox/ez/matrix.c **** 
 204               		.loc 1 107 0
 205 0000 0E94 0000 		call init_mcp23018
 206               	.LVL6:
 207 0004 8093 0000 		sts mcp23018_status,r24
 110:keyboards/ergodox/ez/matrix.c ****     init_cols();
 208               		.loc 1 110 0
 209 0008 0E94 0000 		call unselect_rows
 210               	.LVL7:
 111:keyboards/ergodox/ez/matrix.c **** 
 211               		.loc 1 111 0
 212 000c 0E94 0000 		call init_cols
 213               	.LVL8:
 214 0010 E0E0      		ldi r30,lo8(matrix)
 215 0012 F0E0      		ldi r31,hi8(matrix)
 216 0014 A0E0      		ldi r26,lo8(matrix_debouncing)
 217 0016 B0E0      		ldi r27,hi8(matrix_debouncing)
 218               	.LVL9:
 219               	.L15:
 220               	.LBB9:
 115:keyboards/ergodox/ez/matrix.c ****         matrix_debouncing[i] = 0;
 221               		.loc 1 115 0 discriminator 3
 222 0018 1192      		st Z+,__zero_reg__
 223               	.LVL10:
 116:keyboards/ergodox/ez/matrix.c ****     }
 224               		.loc 1 116 0 discriminator 3
 225 001a 1D92      		st X+,__zero_reg__
 226               	.LVL11:
 114:keyboards/ergodox/ez/matrix.c ****         matrix[i] = 0;
 227               		.loc 1 114 0 discriminator 3
 228 001c 80E0      		ldi r24,hi8(matrix+14)
 229 001e E030      		cpi r30,lo8(matrix+14)
 230 0020 F807      		cpc r31,r24
 231 0022 01F4      		brne .L15
 232               	.LBE9:
 124:keyboards/ergodox/ez/matrix.c **** 
 233               		.loc 1 124 0
 234 0024 0C94 0000 		jmp matrix_init_kb
 235               	.LVL12:
 236               		.cfi_endproc
 237               	.LFE130:
 239               		.section	.text.matrix_power_up,"ax",@progbits
 240               	.global	matrix_power_up
 242               	matrix_power_up:
 243               	.LFB131:
 128:keyboards/ergodox/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 244               		.loc 1 128 0
 245               		.cfi_startproc
 246               	/* prologue: function */
 247               	/* frame size = 0 */
 248               	/* stack size = 0 */
 249               	.L__stack_usage = 0
 129:keyboards/ergodox/ez/matrix.c **** 
 250               		.loc 1 129 0
 251 0000 0E94 0000 		call init_mcp23018
 252               	.LVL13:
 253 0004 8093 0000 		sts mcp23018_status,r24
 131:keyboards/ergodox/ez/matrix.c ****     init_cols();
 254               		.loc 1 131 0
 255 0008 0E94 0000 		call unselect_rows
 256               	.LVL14:
 132:keyboards/ergodox/ez/matrix.c **** 
 257               		.loc 1 132 0
 258 000c 0E94 0000 		call init_cols
 259               	.LVL15:
 260 0010 E0E0      		ldi r30,lo8(matrix)
 261 0012 F0E0      		ldi r31,hi8(matrix)
 262 0014 A0E0      		ldi r26,lo8(matrix_debouncing)
 263 0016 B0E0      		ldi r27,hi8(matrix_debouncing)
 264               	.LVL16:
 265               	.L18:
 266               	.LBB10:
 136:keyboards/ergodox/ez/matrix.c ****         matrix_debouncing[i] = 0;
 267               		.loc 1 136 0 discriminator 3
 268 0018 1192      		st Z+,__zero_reg__
 269               	.LVL17:
 137:keyboards/ergodox/ez/matrix.c ****     }
 270               		.loc 1 137 0 discriminator 3
 271 001a 1D92      		st X+,__zero_reg__
 272               	.LVL18:
 135:keyboards/ergodox/ez/matrix.c ****         matrix[i] = 0;
 273               		.loc 1 135 0 discriminator 3
 274 001c 80E0      		ldi r24,hi8(matrix+14)
 275 001e E030      		cpi r30,lo8(matrix+14)
 276 0020 F807      		cpc r31,r24
 277 0022 01F4      		brne .L18
 278               	/* epilogue start */
 279               	.LBE10:
 145:keyboards/ergodox/ez/matrix.c **** 
 280               		.loc 1 145 0
 281 0024 0895      		ret
 282               		.cfi_endproc
 283               	.LFE131:
 285               		.section	.text.matrix_scan,"ax",@progbits
 286               	.global	matrix_scan
 288               	matrix_scan:
 289               	.LFB132:
 148:keyboards/ergodox/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 290               		.loc 1 148 0
 291               		.cfi_startproc
 292 0000 6F92      		push r6
 293               	.LCFI0:
 294               		.cfi_def_cfa_offset 3
 295               		.cfi_offset 6, -2
 296 0002 7F92      		push r7
 297               	.LCFI1:
 298               		.cfi_def_cfa_offset 4
 299               		.cfi_offset 7, -3
 300 0004 9F92      		push r9
 301               	.LCFI2:
 302               		.cfi_def_cfa_offset 5
 303               		.cfi_offset 9, -4
 304 0006 AF92      		push r10
 305               	.LCFI3:
 306               		.cfi_def_cfa_offset 6
 307               		.cfi_offset 10, -5
 308 0008 BF92      		push r11
 309               	.LCFI4:
 310               		.cfi_def_cfa_offset 7
 311               		.cfi_offset 11, -6
 312 000a CF92      		push r12
 313               	.LCFI5:
 314               		.cfi_def_cfa_offset 8
 315               		.cfi_offset 12, -7
 316 000c DF92      		push r13
 317               	.LCFI6:
 318               		.cfi_def_cfa_offset 9
 319               		.cfi_offset 13, -8
 320 000e EF92      		push r14
 321               	.LCFI7:
 322               		.cfi_def_cfa_offset 10
 323               		.cfi_offset 14, -9
 324 0010 FF92      		push r15
 325               	.LCFI8:
 326               		.cfi_def_cfa_offset 11
 327               		.cfi_offset 15, -10
 328 0012 1F93      		push r17
 329               	.LCFI9:
 330               		.cfi_def_cfa_offset 12
 331               		.cfi_offset 17, -11
 332 0014 CF93      		push r28
 333               	.LCFI10:
 334               		.cfi_def_cfa_offset 13
 335               		.cfi_offset 28, -12
 336 0016 DF93      		push r29
 337               	.LCFI11:
 338               		.cfi_def_cfa_offset 14
 339               		.cfi_offset 29, -13
 340               	/* prologue: function */
 341               	/* frame size = 0 */
 342               	/* stack size = 12 */
 343               	.L__stack_usage = 12
 149:keyboards/ergodox/ez/matrix.c ****         if (++mcp23018_reset_loop == 0) {
 344               		.loc 1 149 0
 345 0018 8091 0000 		lds r24,mcp23018_status
 346 001c 8823      		tst r24
 347 001e 01F0      		breq .L22
 150:keyboards/ergodox/ez/matrix.c ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 348               		.loc 1 150 0
 349 0020 8091 0000 		lds r24,mcp23018_reset_loop
 350 0024 8F5F      		subi r24,lo8(-(1))
 351 0026 8093 0000 		sts mcp23018_reset_loop,r24
 352 002a 8111      		cpse r24,__zero_reg__
 353 002c 00C0      		rjmp .L22
 154:keyboards/ergodox/ez/matrix.c ****             if (mcp23018_status) {
 354               		.loc 1 154 0
 355 002e 0E94 0000 		call init_mcp23018
 356               	.LVL19:
 357 0032 8093 0000 		sts mcp23018_status,r24
 155:keyboards/ergodox/ez/matrix.c ****                 print("left side not responding\n");
 358               		.loc 1 155 0
 359 0036 8111      		cpse r24,__zero_reg__
 360 0038 00C0      		rjmp .L22
 159:keyboards/ergodox/ez/matrix.c ****             }
 361               		.loc 1 159 0
 362 003a 0E94 0000 		call ergodox_blink_all_leds
 363               	.LVL20:
 364               	.L22:
 365 003e 80E0      		ldi r24,lo8(matrix_debouncing)
 366 0040 E82E      		mov r14,r24
 367 0042 80E0      		ldi r24,hi8(matrix_debouncing)
 368 0044 F82E      		mov r15,r24
 148:keyboards/ergodox/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 369               		.loc 1 148 0 discriminator 1
 370 0046 3701      		movw r6,r14
 371 0048 C0E0      		ldi r28,0
 372 004a D0E0      		ldi r29,0
 373               	.LBB23:
 374               	.LBB24:
 375               	.LBB25:
 376               	.LBB26:
 328:keyboards/ergodox/ez/matrix.c **** }
 329:keyboards/ergodox/ez/matrix.c **** 
 330:keyboards/ergodox/ez/matrix.c **** static void select_row(uint8_t row)
 331:keyboards/ergodox/ez/matrix.c **** {
 332:keyboards/ergodox/ez/matrix.c ****     if (row < 7) {
 333:keyboards/ergodox/ez/matrix.c ****         // select on mcp23018
 334:keyboards/ergodox/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 335:keyboards/ergodox/ez/matrix.c ****             // do nothing
 336:keyboards/ergodox/ez/matrix.c ****         } else {
 337:keyboards/ergodox/ez/matrix.c ****             // set active row low  : 0
 338:keyboards/ergodox/ez/matrix.c ****             // set other rows hi-Z : 1
 339:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);        if (mcp23018_status) goto out;
 340:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 341:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 377               		.loc 1 341 0 discriminator 1
 378 004c CC24      		clr r12
 379 004e C394      		inc r12
 380 0050 D12C      		mov r13,__zero_reg__
 381 0052 AA24      		clr r10
 382 0054 A394      		inc r10
 383               	.LBE26:
 384               	.LBE25:
 187:keyboards/ergodox/ez/matrix.c ****         }
 385               		.loc 1 187 0 discriminator 1
 386 0056 25E0      		ldi r18,lo8(5)
 387 0058 922E      		mov r9,r18
 388               	.LVL21:
 389               	.L48:
 390 005a 1C2F      		mov r17,r28
 391               	.LVL22:
 392               	.LBB28:
 393               	.LBB27:
 332:keyboards/ergodox/ez/matrix.c ****         // select on mcp23018
 394               		.loc 1 332 0
 395 005c C730      		cpi r28,lo8(7)
 396 005e 00F4      		brsh .L24
 334:keyboards/ergodox/ez/matrix.c ****             // do nothing
 397               		.loc 1 334 0
 398 0060 8091 0000 		lds r24,mcp23018_status
 399 0064 8111      		cpse r24,__zero_reg__
 400 0066 00C0      		rjmp .L25
 339:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 401               		.loc 1 339 0
 402 0068 80E4      		ldi r24,lo8(64)
 403 006a 0E94 0000 		call i2c_start
 404               	.LVL23:
 405 006e 8093 0000 		sts mcp23018_status,r24
 406 0072 8111      		cpse r24,__zero_reg__
 407 0074 00C0      		rjmp .L27
 340:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 408               		.loc 1 340 0
 409 0076 82E1      		ldi r24,lo8(18)
 410 0078 0E94 0000 		call i2c_write
 411               	.LVL24:
 412 007c 8093 0000 		sts mcp23018_status,r24
 413 0080 8111      		cpse r24,__zero_reg__
 414 0082 00C0      		rjmp .L27
 415               		.loc 1 341 0
 416 0084 C601      		movw r24,r12
 417 0086 0C2E      		mov r0,r28
 418 0088 00C0      		rjmp 2f
 419               		1:
 420 008a 880F      		lsl r24
 421               		2:
 422 008c 0A94      		dec r0
 423 008e 02F4      		brpl 1b
 424 0090 8095      		com r24
 425 0092 0E94 0000 		call i2c_write
 426               	.LVL25:
 427 0096 8093 0000 		sts mcp23018_status,r24
 428               	.L27:
 342:keyboards/ergodox/ez/matrix.c ****                                   & ~(0<<7)
 343:keyboards/ergodox/ez/matrix.c ****                               );                                if (mcp23018_status) goto out;
 344:keyboards/ergodox/ez/matrix.c ****         out:
 345:keyboards/ergodox/ez/matrix.c ****             i2c_stop();
 429               		.loc 1 345 0
 430 009a 0E94 0000 		call i2c_stop
 431               	.LVL26:
 432 009e 00C0      		rjmp .L25
 433               	.L24:
 346:keyboards/ergodox/ez/matrix.c ****         }
 347:keyboards/ergodox/ez/matrix.c ****     } else {
 348:keyboards/ergodox/ez/matrix.c ****         // select on teensy
 349:keyboards/ergodox/ez/matrix.c ****         // Output low(DDR:1, PORT:0) to select
 350:keyboards/ergodox/ez/matrix.c ****         switch (row) {
 434               		.loc 1 350 0
 435 00a0 CA30      		cpi r28,lo8(10)
 436 00a2 01F0      		breq .L30
 437 00a4 00F4      		brsh .L31
 438 00a6 C830      		cpi r28,lo8(8)
 439 00a8 01F0      		breq .L32
 440 00aa C930      		cpi r28,lo8(9)
 441 00ac 01F0      		breq .L33
 442 00ae 00C0      		rjmp .L29
 443               	.L31:
 444 00b0 CC30      		cpi r28,lo8(12)
 445 00b2 01F0      		breq .L34
 446 00b4 00F0      		brlo .L35
 447 00b6 CD30      		cpi r28,lo8(13)
 448 00b8 01F0      		breq .L36
 449               	.L29:
 351:keyboards/ergodox/ez/matrix.c ****             case 7:
 352:keyboards/ergodox/ez/matrix.c ****                 DDRB  |= (1<<0);
 450               		.loc 1 352 0
 451 00ba 209A      		sbi 0x4,0
 353:keyboards/ergodox/ez/matrix.c ****                 PORTB &= ~(1<<0);
 452               		.loc 1 353 0
 453 00bc 2898      		cbi 0x5,0
 454 00be 00C0      		rjmp .L25
 455               	.L32:
 354:keyboards/ergodox/ez/matrix.c ****                 break;
 355:keyboards/ergodox/ez/matrix.c ****             case 8:
 356:keyboards/ergodox/ez/matrix.c ****                 DDRB  |= (1<<1);
 456               		.loc 1 356 0
 457 00c0 219A      		sbi 0x4,1
 357:keyboards/ergodox/ez/matrix.c ****                 PORTB &= ~(1<<1);
 458               		.loc 1 357 0
 459 00c2 2998      		cbi 0x5,1
 460 00c4 00C0      		rjmp .L25
 461               	.L33:
 358:keyboards/ergodox/ez/matrix.c ****                 break;
 359:keyboards/ergodox/ez/matrix.c ****             case 9:
 360:keyboards/ergodox/ez/matrix.c ****                 DDRB  |= (1<<2);
 462               		.loc 1 360 0
 463 00c6 229A      		sbi 0x4,2
 361:keyboards/ergodox/ez/matrix.c ****                 PORTB &= ~(1<<2);
 464               		.loc 1 361 0
 465 00c8 2A98      		cbi 0x5,2
 466 00ca 00C0      		rjmp .L25
 467               	.L30:
 362:keyboards/ergodox/ez/matrix.c ****                 break;
 363:keyboards/ergodox/ez/matrix.c ****             case 10:
 364:keyboards/ergodox/ez/matrix.c ****                 DDRB  |= (1<<3);
 468               		.loc 1 364 0
 469 00cc 239A      		sbi 0x4,3
 365:keyboards/ergodox/ez/matrix.c ****                 PORTB &= ~(1<<3);
 470               		.loc 1 365 0
 471 00ce 2B98      		cbi 0x5,3
 472 00d0 00C0      		rjmp .L25
 473               	.L35:
 366:keyboards/ergodox/ez/matrix.c ****                 break;
 367:keyboards/ergodox/ez/matrix.c ****             case 11:
 368:keyboards/ergodox/ez/matrix.c ****                 DDRD  |= (1<<2);
 474               		.loc 1 368 0
 475 00d2 529A      		sbi 0xa,2
 476 00d4 00C0      		rjmp .L62
 477               	.L34:
 369:keyboards/ergodox/ez/matrix.c ****                 PORTD &= ~(1<<3);
 370:keyboards/ergodox/ez/matrix.c ****                 break;
 371:keyboards/ergodox/ez/matrix.c ****             case 12:
 372:keyboards/ergodox/ez/matrix.c ****                 DDRD  |= (1<<3);
 478               		.loc 1 372 0
 479 00d6 539A      		sbi 0xa,3
 480               	.L62:
 373:keyboards/ergodox/ez/matrix.c ****                 PORTD &= ~(1<<3);
 481               		.loc 1 373 0
 482 00d8 5B98      		cbi 0xb,3
 483 00da 00C0      		rjmp .L25
 484               	.L36:
 374:keyboards/ergodox/ez/matrix.c ****                 break;
 375:keyboards/ergodox/ez/matrix.c ****             case 13:
 376:keyboards/ergodox/ez/matrix.c ****                 DDRC  |= (1<<6);
 485               		.loc 1 376 0
 486 00dc 3E9A      		sbi 0x7,6
 377:keyboards/ergodox/ez/matrix.c ****                 PORTC &= ~(1<<6);
 487               		.loc 1 377 0
 488 00de 4698      		cbi 0x8,6
 489               	.L25:
 490               	.LVL27:
 491               	.LBE27:
 492               	.LBE28:
 493               	.LBB29:
 494               	.LBB30:
 495               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 496               		.loc 2 276 0
 497 00e0 80EA      		ldi r24,lo8(-96)
 498 00e2 8A95      	1:	dec r24
 499 00e4 01F4      		brne 1b
 500               	.LVL28:
 501               	.LBE30:
 502               	.LBE29:
 503               	.LBB31:
 504               	.LBB32:
 268:keyboards/ergodox/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 505               		.loc 1 268 0
 506 00e6 1730      		cpi r17,lo8(7)
 507 00e8 00F4      		brsh .L37
 269:keyboards/ergodox/ez/matrix.c ****             return 0;
 508               		.loc 1 269 0
 509 00ea 8091 0000 		lds r24,mcp23018_status
 510 00ee 8111      		cpse r24,__zero_reg__
 511 00f0 00C0      		rjmp .L54
 512               	.LVL29:
 513               	.LBB33:
 273:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 514               		.loc 1 273 0
 515 00f2 80E4      		ldi r24,lo8(64)
 516 00f4 0E94 0000 		call i2c_start
 517               	.LVL30:
 518 00f8 8093 0000 		sts mcp23018_status,r24
 519 00fc 8823      		tst r24
 520 00fe 01F0      		breq .L39
 521               	.L41:
 272:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 522               		.loc 1 272 0
 523 0100 B12C      		mov r11,__zero_reg__
 524 0102 00C0      		rjmp .L40
 525               	.L39:
 274:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 526               		.loc 1 274 0
 527 0104 83E1      		ldi r24,lo8(19)
 528 0106 0E94 0000 		call i2c_write
 529               	.LVL31:
 530 010a 8093 0000 		sts mcp23018_status,r24
 531 010e 8111      		cpse r24,__zero_reg__
 532 0110 00C0      		rjmp .L41
 275:keyboards/ergodox/ez/matrix.c ****             data = i2c_readNak();
 533               		.loc 1 275 0
 534 0112 81E4      		ldi r24,lo8(65)
 535 0114 0E94 0000 		call i2c_start
 536               	.LVL32:
 537 0118 8093 0000 		sts mcp23018_status,r24
 538 011c 8111      		cpse r24,__zero_reg__
 539 011e 00C0      		rjmp .L41
 276:keyboards/ergodox/ez/matrix.c ****             data = ~data;
 540               		.loc 1 276 0
 541 0120 0E94 0000 		call i2c_readNak
 542               	.LVL33:
 277:keyboards/ergodox/ez/matrix.c ****         out:
 543               		.loc 1 277 0
 544 0124 B82E      		mov r11,r24
 545 0126 B094      		com r11
 546               	.LVL34:
 547               	.L40:
 279:keyboards/ergodox/ez/matrix.c ****             return data;
 548               		.loc 1 279 0
 549 0128 0E94 0000 		call i2c_stop
 550               	.LVL35:
 280:keyboards/ergodox/ez/matrix.c ****         }
 551               		.loc 1 280 0
 552 012c 8B2D      		mov r24,r11
 553 012e 00C0      		rjmp .L38
 554               	.LVL36:
 555               	.L37:
 556               	.LBE33:
 285:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 557               		.loc 1 285 0
 558 0130 8FB1      		in r24,0xf
 559 0132 8170      		andi r24,lo8(1)
 560 0134 8A25      		eor r24,r10
 561 0136 7999      		sbic 0xf,1
 562 0138 00C0      		rjmp .L55
 563 013a 32E0      		ldi r19,lo8(2)
 564 013c 00C0      		rjmp .L42
 565               	.L55:
 566 013e 30E0      		ldi r19,0
 567               	.L42:
 568 0140 832B      		or r24,r19
 569 0142 7C99      		sbic 0xf,4
 570 0144 00C0      		rjmp .L56
 571 0146 34E0      		ldi r19,lo8(4)
 572 0148 00C0      		rjmp .L43
 573               	.L56:
 574 014a 30E0      		ldi r19,0
 575               	.L43:
 576 014c 832B      		or r24,r19
 577 014e 7D99      		sbic 0xf,5
 578 0150 00C0      		rjmp .L57
 579 0152 28E0      		ldi r18,lo8(8)
 580 0154 00C0      		rjmp .L44
 581               	.L57:
 582 0156 20E0      		ldi r18,0
 583               	.L44:
 584 0158 822B      		or r24,r18
 585 015a 7E99      		sbic 0xf,6
 586 015c 00C0      		rjmp .L58
 587 015e 90E1      		ldi r25,lo8(16)
 588 0160 00C0      		rjmp .L45
 589               	.L58:
 590 0162 90E0      		ldi r25,0
 591               	.L45:
 592 0164 892B      		or r24,r25
 290:keyboards/ergodox/ez/matrix.c ****     }
 593               		.loc 1 290 0
 594 0166 9FB1      		in r25,0xf
 285:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 595               		.loc 1 285 0
 596 0168 9095      		com r25
 597 016a 991F      		rol r25
 598 016c 9927      		clr r25
 599 016e 991F      		rol r25
 600 0170 9295      		swap r25
 601 0172 990F      		lsl r25
 602 0174 907E      		andi r25,lo8(-32)
 603 0176 892B      		or r24,r25
 604 0178 00C0      		rjmp .L38
 605               	.L54:
 270:keyboards/ergodox/ez/matrix.c ****         } else {
 606               		.loc 1 270 0
 607 017a 80E0      		ldi r24,0
 608               	.L38:
 609               	.LVL37:
 610               	.LBE32:
 611               	.LBE31:
 182:keyboards/ergodox/ez/matrix.c ****             matrix_debouncing[i] = cols;
 612               		.loc 1 182 0
 613 017c D301      		movw r26,r6
 614 017e 9C91      		ld r25,X
 615 0180 9817      		cp r25,r24
 616 0182 01F0      		breq .L47
 183:keyboards/ergodox/ez/matrix.c ****             if (debouncing) {
 617               		.loc 1 183 0
 618 0184 8C93      		st X,r24
 187:keyboards/ergodox/ez/matrix.c ****         }
 619               		.loc 1 187 0
 620 0186 9092 0000 		sts debouncing,r9
 621               	.L47:
 189:keyboards/ergodox/ez/matrix.c ****     }
 622               		.loc 1 189 0 discriminator 2
 623 018a 0E94 0000 		call unselect_rows
 624               	.LVL38:
 625 018e 2196      		adiw r28,1
 626               	.LVL39:
 627 0190 BFEF      		ldi r27,-1
 628 0192 6B1A      		sub r6,r27
 629 0194 7B0A      		sbc r7,r27
 630               	.LBE24:
 178:keyboards/ergodox/ez/matrix.c ****         select_row(i);
 631               		.loc 1 178 0 discriminator 2
 632 0196 CE30      		cpi r28,14
 633 0198 D105      		cpc r29,__zero_reg__
 634 019a 01F0      		breq .+2
 635 019c 00C0      		rjmp .L48
 636               	.LBE23:
 192:keyboards/ergodox/ez/matrix.c ****         if (--debouncing) {
 637               		.loc 1 192 0
 638 019e 8091 0000 		lds r24,debouncing
 639 01a2 8823      		tst r24
 640 01a4 01F0      		breq .L50
 193:keyboards/ergodox/ez/matrix.c ****             wait_us(1);
 641               		.loc 1 193 0
 642 01a6 8150      		subi r24,lo8(-(-1))
 643 01a8 8093 0000 		sts debouncing,r24
 644 01ac 8823      		tst r24
 645 01ae 01F0      		breq .L51
 646               	.LVL40:
 647               	.LBB34:
 648               	.LBB35:
 649               		.loc 2 276 0
 650 01b0 E5E0      		ldi r30,lo8(5)
 651 01b2 EA95      	1:	dec r30
 652 01b4 01F4      		brne 1b
 653 01b6 0000      		nop
 654 01b8 00C0      		rjmp .L50
 655               	.LVL41:
 656               	.L51:
 657 01ba E0E0      		ldi r30,lo8(matrix)
 658 01bc F0E0      		ldi r31,hi8(matrix)
 659               	.L52:
 660               	.LVL42:
 661               	.LBE35:
 662               	.LBE34:
 663               	.LBB36:
 198:keyboards/ergodox/ez/matrix.c ****             }
 664               		.loc 1 198 0 discriminator 3
 665 01be D701      		movw r26,r14
 666 01c0 8D91      		ld r24,X+
 667 01c2 7D01      		movw r14,r26
 668               	.LVL43:
 669 01c4 8193      		st Z+,r24
 670               	.LVL44:
 197:keyboards/ergodox/ez/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 671               		.loc 1 197 0 discriminator 3
 672 01c6 B0E0      		ldi r27,lo8(matrix_debouncing+14)
 673 01c8 EB16      		cp r14,r27
 674 01ca B0E0      		ldi r27,hi8(matrix_debouncing+14)
 675 01cc FB06      		cpc r15,r27
 676 01ce 01F4      		brne .L52
 677               	.LVL45:
 678               	.L50:
 679               	.LBE36:
 203:keyboards/ergodox/ez/matrix.c **** 
 680               		.loc 1 203 0
 681 01d0 0E94 0000 		call matrix_scan_quantum
 682               	.LVL46:
 206:keyboards/ergodox/ez/matrix.c **** 
 683               		.loc 1 206 0
 684 01d4 81E0      		ldi r24,lo8(1)
 685               	/* epilogue start */
 686 01d6 DF91      		pop r29
 687 01d8 CF91      		pop r28
 688               	.LVL47:
 689 01da 1F91      		pop r17
 690 01dc FF90      		pop r15
 691 01de EF90      		pop r14
 692 01e0 DF90      		pop r13
 693 01e2 CF90      		pop r12
 694 01e4 BF90      		pop r11
 695 01e6 AF90      		pop r10
 696 01e8 9F90      		pop r9
 697 01ea 7F90      		pop r7
 698 01ec 6F90      		pop r6
 699 01ee 0895      		ret
 700               		.cfi_endproc
 701               	.LFE132:
 703               		.section	.text.matrix_is_modified,"ax",@progbits
 704               	.global	matrix_is_modified
 706               	matrix_is_modified:
 707               	.LFB133:
 209:keyboards/ergodox/ez/matrix.c ****     if (debouncing) return false;
 708               		.loc 1 209 0
 709               		.cfi_startproc
 710               	/* prologue: function */
 711               	/* frame size = 0 */
 712               	/* stack size = 0 */
 713               	.L__stack_usage = 0
 714 0000 81E0      		ldi r24,lo8(1)
 715 0002 9091 0000 		lds r25,debouncing
 716 0006 9111      		cpse r25,__zero_reg__
 717 0008 80E0      		ldi r24,0
 718               	.L64:
 212:keyboards/ergodox/ez/matrix.c **** 
 719               		.loc 1 212 0
 720 000a 0895      		ret
 721               		.cfi_endproc
 722               	.LFE133:
 724               		.section	.text.matrix_is_on,"ax",@progbits
 725               	.global	matrix_is_on
 727               	matrix_is_on:
 728               	.LFB134:
 216:keyboards/ergodox/ez/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 729               		.loc 1 216 0
 730               		.cfi_startproc
 731               	.LVL48:
 732               	/* prologue: function */
 733               	/* frame size = 0 */
 734               	/* stack size = 0 */
 735               	.L__stack_usage = 0
 217:keyboards/ergodox/ez/matrix.c **** }
 736               		.loc 1 217 0
 737 0000 E82F      		mov r30,r24
 738 0002 F0E0      		ldi r31,0
 739 0004 E050      		subi r30,lo8(-(matrix))
 740 0006 F040      		sbci r31,hi8(-(matrix))
 741 0008 2081      		ld r18,Z
 742 000a 822F      		mov r24,r18
 743               	.LVL49:
 744 000c 90E0      		ldi r25,0
 745 000e 21E0      		ldi r18,lo8(1)
 746 0010 30E0      		ldi r19,0
 747 0012 00C0      		rjmp 2f
 748               		1:
 749 0014 220F      		lsl r18
 750 0016 331F      		rol r19
 751               		2:
 752 0018 6A95      		dec r22
 753 001a 02F4      		brpl 1b
 754 001c 2823      		and r18,r24
 755 001e 3923      		and r19,r25
 756 0020 81E0      		ldi r24,lo8(1)
 757 0022 232B      		or r18,r19
 758 0024 01F4      		brne .L69
 759 0026 80E0      		ldi r24,0
 760               	.L69:
 218:keyboards/ergodox/ez/matrix.c **** 
 761               		.loc 1 218 0
 762 0028 0895      		ret
 763               		.cfi_endproc
 764               	.LFE134:
 766               		.section	.text.matrix_get_row,"ax",@progbits
 767               	.global	matrix_get_row
 769               	matrix_get_row:
 770               	.LFB135:
 222:keyboards/ergodox/ez/matrix.c ****     return matrix[row];
 771               		.loc 1 222 0
 772               		.cfi_startproc
 773               	.LVL50:
 774               	/* prologue: function */
 775               	/* frame size = 0 */
 776               	/* stack size = 0 */
 777               	.L__stack_usage = 0
 223:keyboards/ergodox/ez/matrix.c **** }
 778               		.loc 1 223 0
 779 0000 E82F      		mov r30,r24
 780 0002 F0E0      		ldi r31,0
 781 0004 E050      		subi r30,lo8(-(matrix))
 782 0006 F040      		sbci r31,hi8(-(matrix))
 224:keyboards/ergodox/ez/matrix.c **** 
 783               		.loc 1 224 0
 784 0008 8081      		ld r24,Z
 785               	.LVL51:
 786 000a 0895      		ret
 787               		.cfi_endproc
 788               	.LFE135:
 790               		.section	.text.matrix_print,"ax",@progbits
 791               	.global	matrix_print
 793               	matrix_print:
 794               	.LFB136:
 227:keyboards/ergodox/ez/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 795               		.loc 1 227 0
 796               		.cfi_startproc
 797               	/* prologue: function */
 798               	/* frame size = 0 */
 799               	/* stack size = 0 */
 800               	.L__stack_usage = 0
 801               	.LVL52:
 802 0000 0895      		ret
 803               		.cfi_endproc
 804               	.LFE136:
 806               		.section	.text.matrix_key_count,"ax",@progbits
 807               	.global	matrix_key_count
 809               	matrix_key_count:
 810               	.LFB137:
 237:keyboards/ergodox/ez/matrix.c ****     uint8_t count = 0;
 811               		.loc 1 237 0
 812               		.cfi_startproc
 237:keyboards/ergodox/ez/matrix.c ****     uint8_t count = 0;
 813               		.loc 1 237 0
 814 0000 0F93      		push r16
 815               	.LCFI12:
 816               		.cfi_def_cfa_offset 3
 817               		.cfi_offset 16, -2
 818 0002 1F93      		push r17
 819               	.LCFI13:
 820               		.cfi_def_cfa_offset 4
 821               		.cfi_offset 17, -3
 822 0004 CF93      		push r28
 823               	.LCFI14:
 824               		.cfi_def_cfa_offset 5
 825               		.cfi_offset 28, -4
 826               	/* prologue: function */
 827               	/* frame size = 0 */
 828               	/* stack size = 3 */
 829               	.L__stack_usage = 3
 830               	.LVL53:
 831 0006 00E0      		ldi r16,lo8(matrix)
 832 0008 10E0      		ldi r17,hi8(matrix)
 238:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 833               		.loc 1 238 0
 834 000a C0E0      		ldi r28,0
 835               	.LVL54:
 836               	.L73:
 837               	.LBB37:
 240:keyboards/ergodox/ez/matrix.c ****     }
 838               		.loc 1 240 0 discriminator 3
 839 000c F801      		movw r30,r16
 840 000e 8191      		ld r24,Z+
 841 0010 8F01      		movw r16,r30
 842               	.LVL55:
 843 0012 90E0      		ldi r25,0
 844 0014 0E94 0000 		call bitpop16
 845               	.LVL56:
 846 0018 C80F      		add r28,r24
 847               	.LVL57:
 239:keyboards/ergodox/ez/matrix.c ****         count += bitpop16(matrix[i]);
 848               		.loc 1 239 0 discriminator 3
 849 001a F0E0      		ldi r31,hi8(matrix+14)
 850 001c 0030      		cpi r16,lo8(matrix+14)
 851 001e 1F07      		cpc r17,r31
 852 0020 01F4      		brne .L73
 853               	.LBE37:
 243:keyboards/ergodox/ez/matrix.c **** 
 854               		.loc 1 243 0
 855 0022 8C2F      		mov r24,r28
 856               	/* epilogue start */
 857 0024 CF91      		pop r28
 858               	.LVL58:
 859 0026 1F91      		pop r17
 860 0028 0F91      		pop r16
 861               	.LVL59:
 862 002a 0895      		ret
 863               		.cfi_endproc
 864               	.LFE137:
 866               		.section	.bss.mcp23018_reset_loop,"aw",@nobits
 869               	mcp23018_reset_loop:
 870 0000 00        		.zero	1
 871               		.section	.bss.matrix_debouncing,"aw",@nobits
 874               	matrix_debouncing:
 875 0000 0000 0000 		.zero	14
 875      0000 0000 
 875      0000 0000 
 875      0000 
 876               		.section	.bss.matrix,"aw",@nobits
 879               	matrix:
 880 0000 0000 0000 		.zero	14
 880      0000 0000 
 880      0000 0000 
 880      0000 
 881               		.section	.data.debouncing,"aw",@progbits
 884               	debouncing:
 885 0000 05        		.byte	5
 886               		.text
 887               	.Letext0:
 888               		.file 3 "/usr/lib/avr/include/stdint.h"
 889               		.file 4 "./tmk_core/common/matrix.h"
 890               		.file 5 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 891               		.file 6 "keyboards/ergodox/ez/ez.h"
 892               		.file 7 "keyboards/ergodox/ez/i2cmaster.h"
 893               		.file 8 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cc1XPfR4.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc1XPfR4.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc1XPfR4.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc1XPfR4.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc1XPfR4.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc1XPfR4.s:12     .text.init_cols:0000000000000000 init_cols
     /tmp/cc1XPfR4.s:35     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/cc1XPfR4.s:98     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/cc1XPfR4.s:98     .text.matrix_scan_user:0000000000000000 matrix_scan_user.localalias.0
     /tmp/cc1XPfR4.s:114    .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/cc1XPfR4.s:128    .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/cc1XPfR4.s:145    .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/cc1XPfR4.s:162    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cc1XPfR4.s:179    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cc1XPfR4.s:196    .text.matrix_init:0000000000000000 matrix_init
     /tmp/cc1XPfR4.s:879    .bss.matrix:0000000000000000 matrix
     /tmp/cc1XPfR4.s:874    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/cc1XPfR4.s:242    .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/cc1XPfR4.s:288    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cc1XPfR4.s:869    .bss.mcp23018_reset_loop:0000000000000000 mcp23018_reset_loop
     /tmp/cc1XPfR4.s:884    .data.debouncing:0000000000000000 debouncing
     /tmp/cc1XPfR4.s:706    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cc1XPfR4.s:727    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cc1XPfR4.s:769    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cc1XPfR4.s:793    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cc1XPfR4.s:809    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
mcp23018_status
i2c_start
i2c_write
i2c_stop
init_mcp23018
ergodox_blink_all_leds
i2c_readNak
matrix_scan_quantum
bitpop16
__do_copy_data
__do_clear_bss
